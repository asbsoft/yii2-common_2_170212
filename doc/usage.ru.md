
Расширение Yii2-фреймворка для поддержки модулей-пакетов
========================================================

Модуль UniModule (united/unified, объединенный модуль) - концепция модуля-пакета,
полностью содержащая в себе решение какой-либо пользовательской задачи на базе Yii2-фреймворка.
Такой модуль содержит вместе и frontend, и backend-части, подмодули, и все необходимые модулю ресурсы,
имеет гибкие средства построения роутов, может наследоваться и расширяться
в виде нового модуля в другом пространстве имен, допускается цепочка наследований.
Для поддержки данной функциональности в рамках приложений, базирующихся на Yii2-фреймворке,
и служит asbsoft/yii2-common_2_170212 - набор расширений Yii2 для поддержки модулей-пакетов.

Чтобы познакомиться с работой модулей-пакетов, можно сразу взять демо-приложение asbsoft/yii2-app_4_170405,
где все необходимые настройки сделаны на основе двух стандартных Yii2-приложений (basic, advanced),
которые в данном приложении присутствуют одновременно и даже работают вместе
с общей базой и общими каталогами vendor, project, upload и др.
Но это в демо-версии, так как, к сожалению, в конечном итоге прийдется определиться,
с каким из вариантов (basic или advanced) работать из-за различий в настройках, базе, админ-линках,
менеджере модулей и т.п., которые в реальном проекте может не получиться одновременно поддерживать.
Также в этом демо-проекте по умолчанию (с помощью .htaccess) из корня происходит переход
на фронтенд advanced-приложения, по ссылке /back/ - на бекенд advanced-приложения.
(Вместо этого можно создать субдомены для frontend и backend-частей advanced-приложения,
тогда в /backend/config/main.php нужно присвоить $adminUrlPrefixHtaccess = '' вместо 'back')
Для basic-приложения, находящегося в подкаталоге basic, есть свой /.htaccess (.htaccess.BASIC)
или следует создать субдомен, так как текущие настройки демо-приложений предполагают работу из корня,
что не обязательно для произвольного Yii2-приложения (см. Yii::$app->homeUrl).

Если же нужно использовать эти модули в своем проекте, то кроме установки asbsoft/yii2-common_2_170212
необходимо произвести ряд дополнительный настроек системы.
Здесь приводится пример настроек для стандартных Yii2-приложений, взятых с http://www.yiiframework.com/download/
например https://github.com/yiisoft/yii2/releases/download/2.0.12/yii-advanced-app-2.0.12.tgz
или https://github.com/yiisoft/yii2/releases/download/2.0.12/yii-basic-app-2.0.12.tgz
Ниже перечислены шаги, производившиеся автором при тестовой установке yii2-common_2_170212-части
и нескольких своих демо-модулей в стандартных Yii2-приложениях:
- Прежде всего в /vendor/asbsoft/yii2-common_2_170212/config/ необходимо создать собственные конфиги.
  Данные конфиги понадобятся только в демо-версии, компенсируя в первую очередь отсутствие модуля поддержки языков,
  другие конфиги уже устарели (но могут понадобиться) и еще используются для поддержки обратной совместимости.
- Установить в системе алиасы для автозагрузки и поиска:
  Yii::setAlias('@asb/yii2/common_2_170212', $vendorPath . '/asbsoft/yii2-common_2_170212');
  Yii::setAlias('@asb/yii2/modules',         $vendorPath . '/asbsoft/yii2module');
  Последний алиас можно использовать для добавления новых asbsoft-модулей без composer-а,
  но тогда нужно добавлять модули в vendor-каталог не в первый уровень
  /vendor/asbsoft/yii2module-content_2_170309/ (как это делает composer), а в
  /vendor/asbsoft/yii2module/content_2_170309/ (то есть на уровень глубже - в подкаталог yii2module),
  тогда все модули-пакеты от asbsoft будут находиться в одном подкаталоге /vendor/asbsoft/yii2module/
  и Yii2-автозагрузчик классов будет их там находить без каких-либо дополнительных коррекций конфигов
  так как все они имеют пространства имен, начинающиеся с namespace asb\yii2\modules\...
- В конфиг(и) системы (приложения) необходимо добавить/обновить такие компоненты
  (их можно использовать вместо стандартных, так как используемые common_2_170212-классы
  наследуются от соответствующих стандартных):
  ```php
      'errorHandler' => [
          'class' => 'asb\yii2\common_2_170212\web\UniErrorHandler',  // необходим для перемещения изображений (с обработкой)
                                                                      // из upload-каталога в соответствующий подкаталог в webroot
          'errorAction' => 'site/error',  // error-action по умолчанию из демонстрационных Yii2-приложений - измените, если надо
      ],
      'view' => [
          'class' => 'asb\yii2\common_2_170212\web\UniView',  // необходимо для работы наследования шаблонов
      ],
      'authManager' => [
          'class' => 'yii\rbac\DbManager',  // будет использован стандартный для Yii2 контроль доступа на основе ролей (RBAC)
                                            // который применяется в asbsoft-модулях
      ],
      'urlManager' => [
          'enablePrettyUrl' => true,  // необходимо для добавления в систему роутов из модуля-пакета
          'showScriptName' => false,
          //...
      ],
      'i18n' => [
          'translations' => [
              'common' => [  // будет использовано как Yii::t('common', '...') в общей части кода
                  'class' => 'asb\yii2\common_2_170212\i18n\UniPhpMessageSource',                    
                  'basePath' => '@asb/yii2/common_2_170212/messages',
                  'sourceLanguage' => 'en',
                  'on missingTranslation' => [
                      'asb\yii2\common_2_170212\i18n\TranslationEventHandler',
                      'handleMissingTranslation'  // используется для сбора в логах недостающих переводов
                  ],
              ],
          ],
      ],
  ```
- В конфигах по аналогии с asbsoft/yii2-app_4_170405/project/config/config-app-prepare.php
  надо выполнить такие установщики действий (action) по умолчанию для регистрации отдельно для бекенда и фронтенда:
  \asb\yii2\common_2_170212\controllers\BaseController::setUrlLogin('/site/login'); // или другой login-route-action для frontend
  \asb\yii2\common_2_170212\controllers\BaseAdminController::setUrlLogin('/site/login'); // или другой login-route-action для backend
  - здесь '/site/login' - это то uniqueId того действия (action), которое используется по умолчании в Yii2-приложениях.
- Существует также следующее соглашение насчет иестонахождения upload-файлов - они вначале заливаются
  в подкаталог, корень которого описывается алиасом '@uploadspath', и находящийся вне @webroot (!).
  HTTP-запрос к такому файлу идет как будто он находится в подкаталоге внутри '@webfilespath',
  при таком запросе срабатывает обработчик ошибки asb\yii2\common_2_170212\web\UniErrorHandler,
  который с помощью asb\yii2\common_2_170212\web\WebFile копирует (обработав для безопасности) файл
  из @uploadspath в @webfilespath.
  По умолчанию
    Yii::setAlias('@webfilespath', rtrim(Yii::getAlias('@webroot/' . 'files/')); // кеш для обработанных upload-файлов
    Yii::setAlias('@webfilesurl',  rtrim(Yii::getAlias('@web/' . 'files/'));
  Есть asb\yii2\common_2_170212\base\CommonBootstrap, который выполняет эти и ряд других действий по настройке системы.
  Если эти действия не конфликтуют с целевой системой, можно использовать его.


Basic Yii2-application
----------------------
Настройки для basic Yii2-application несколько отличаются:
- Здесь обязательно надо определить параметр Yii::$app->params['adminPath'] в /config/params.php (params-local.php):
  например 'adminPath' => 'adm'. Это префикс всех линков админки.
  Этот префикс будет приписан всем роутам admin(backend) части модуля (для advanced-application такой префикс не нужен).
  Надо учесть, что в этом приложении также нет специальной модели, работающей с таблицей '{{%user}}',
  все пользователи с паролями определены в app\models\User, добавлять новых надо в текст этого класса.
- Для стандартного basic-приложения у админки должен быть свой layout-шаблон.
  Так как все backend-контроллеры модулей-пакетов наследуют класс BaseAdminController,
  который позволяет указать каталог с шаблонами админки, можно в конфиге @app/config/web.php его указать:
  BaseAdminController::$layoutPathBackend = '@app/views/layouts/backend';
  а в каталоге шаблонов создать этот подкаталог @app/views/layouts/backend,
  поместив туда шаблон main.php (по умолчанию).
  Можно, например, скопировать сюда существующий frontend-шаблон @app/views/layouts/main.php,
  заменив 'My Company' на 'Backend' и убрав лишнее из меню (About, Contact)
  и добавив нужные ссылки на входы в админки модулей.
- Для корня админки надо написать простой контроллер стартовой страницы админки,
  унаследовав его от asb\yii2\common_2_170212\controllers\BaseAdminController,
  например @app/controllers/AdminController.php:
  ```php
    namespace app\controllers;
    class AdminController extends \asb\yii2\common_2_170212\controllers\BaseAdminController
    {
        public function actionIndex()
        {
            return $this->render('index');
        }
    }
  ```
  и добавить его в роуты в конфиге @app/config/web.php для urlManager:
  ```php
    'urlManager' => [
        'enablePrettyUrl' => true,
        'showScriptName' => false,
        'rules' => [
            [
                'pattern' => $params['adminPath'],
                'route' => 'admin/index',
            ],
        ],
        'normalizer' => [ // обработка '/' в конце URL
            'class' => 'yii\web\UrlNormalizer',
            'action' => \yii\web\UrlNormalizer::ACTION_REDIRECT_TEMPORARY,
        ],
  ```


Пользователи и роли
-------------------
В asbsoft-модулях используется контроль доступа на основе ролей (RBAC), реализованный в Yii2.
- Если в системе еще нет ролей, можно использовать стандартный authManager yii\rbac\DbManager,
  запоминающий мнформацию в базе. Для этого необходимо выполнить миграции для добавления ролей
  из /vendor/asbsoft/yii2-common_2_170212/migrations/rbac/.
  Для корректной работы модулей из asbsoft необходимы роли roleRoot и roleAdmin, создаваемые миграцией
  /vendor/asbsoft/yii2-common_2_170212/migrations/rbac/m160524_092000_add_roles_root_admin.php.
  Роль разработчика roleRoot предполагает возможность выполнения всех действий в системе.
  Предполагается, что роль администратора roleAdmin в отличие от roleRoot не будет содержать
  критических возможностей по настройке системы, например манипуляции с модулями.
- Для advanced Yii2-application если в системе для управления пользователями используется
  стандартный класс common\models\User, использующий для хранения данных таблицу '{{%user}}'
  и еще нет пользователей, можно воспользоваться миграциями для их добавления
  из /vendor/asbsoft/yii2-common_2_170212/migrations/
- Обязательно надо проследить, чтобы хоть одному существующему пользователю в системе (администратору)
  была присвоена роль roleRoot или roleAdmin в таблице {{%auth_assignment}}.


Использование модулей-пакетов
-----------------------------
При использование модулей-пакетов надо учесть, что
- Все модули, наследующие класс \asb\yii2\common_2_170212\base\UniModule (или BaseModule), имеют механизм для создания
  собственных настраиваемых роутов из config/routes-...-файлов модуля с нужным префиксом у всех линков.
  Для этого обязательно ID-ы устанавливаемых модулей-пакетов надо добавлять в bootstrap-список
  в общем конфиге приложения (только корневых модулей, вложенных не надо),
  после чего в систему добавятся роуты и переводы модуля и его вложенных подмодулей, если такие есть.
  А чтобы и подмодули инициализировались подобным образом, их следует перечислить в конфиге модуля-контейнера
  в свойстве 'bootstrap' (по аналогии с yii\base\Application модуль-пакет тоже имеет свойство UniModule::$bootstrap).
  В этом смысле любой иодуль-пакет похож на самостоятельное приложение и может быть использован
  как корневой, так и вложенный в другой подобный пакет с минимальной перенастройкой конфигов.
- Если в системе используется примитивный роутинг типа
  '<module:\w+>/<controller:\w+>/<action:\w+>/<param:\w+>' => '<module>/<controller>/<action>',
  то подключать модули из asbsoft напрямую не надо иначе имена модулей типа 'news_1b_160430' появятся в линках,
  что нежелательно. Необходимо делать наследуемые модули в стандартном пространстве имен,
  например \common\modules или \app\modules,
  Например, в простейшем случае можно создать модуль в @app/modules/news/ содержащий только Module.php с кодом
    class Module extends \asb\yii2\modules\news_1b_160430\Module { /* здесь пусто */ }
  Новый модуль унаследует все возможности модуля-пакета news_1b_160430.
  Именно этот "новый" модуль надо добавить в массив 'modules' конфига системы,
  чтобы использовать роуты по умолчанию.
- Но одним из преимуществ использования UniModule-модулей является самостоятельное генерирование роутов,
  описанных в самом модуле в config/routes-TYPE.php файлах. Есть два стандартных TYPE:
  main (для frontend) и admin (для backend), можно использовать и другие, обязательно упомянув о них в 
  config/config.php модуля:
    'rest'  => [
         'class' => RestUrlRule::className(),
         'urlPrefix'  => 'rest-api',
         'sublink' => 'newsrest',
    ],
  Надо учитывать, что к URL-префиксам 'urlPrefix' вложенных модулей будут добавлены префиксы
  из конфигов модулей-контейнеров из того же типа TYPE.
- В advanced-приложении практикуется деление модулей на backend и frontend части.
  Эта возможность также поддерживается, причем любым из перечисленных ниже способов:
  * если создан один модуль-наследник например \common\modules\news\Module
    или даже используется оригинальный модуль напрямую,
    то его надо подключить в конфигах backend и frontend приложений по-разному:
    # \backend\config\main.php:
      ```php
        'news' => [
            'class' => 'common\modules\news\Module',
            'routesConfig' => [
                'main' => false,  // main-часть модуля, отвечающая за frontend, отключается (роуты для нее не генерируются)
            ],
        ],
      ```
    # \frontend\config\main.php:
      ```php
        'news' => [
            'class' => 'common\modules\news\Module',
            'routesConfig' => [
                'admin' => false,  // admin-часть модуля, отвечающая за backend, отключается (роуты для нее не генерируются)
            ],
        ],
        ],
      ```
  * можно создать разные модули-наследники в backend и frontend-частях приложения соответственно,
    а в их конфигах подобным образом отключить ненужные части функциональности.


Наследование модулей, поддерживаемое asb\yii2\common_2_170212\base\UniModule
----------------------------------------------------------------------------
В качестве примера модуля-наследника можно посмотреть asbsoft/yii2module-news_3b_171202,
который наследует, добавляет и частично переопределяет функционал модуля asbsoft/yii2module-news_2b_161124,
который, в свою очередь, наследует функционал модуля asbsoft/yii2module-news_1b_160430.
Внутри вновь созданного наследника можно переопределить практически все компоненты корневого,
создав одноименные файлы в соответствующих местах, при это действуют следующие правила:
- Конфиги и языковые файлы сливаются (merge массивов), причем информация наследников переписывает предков,
  то есть если добавлена одна новая строка-перевод - только ее и надо вносить в новый messages-файл
  или если в конфиге переопределен только один параметр - только его.
- Контроллеры и view используются от последнего потомка, где они переопределены,
  а соответствующие родительские игнорируются, например при поиске действий роута.
  Потомку контроллера надо наследовать класс родителя, чтобы не потерять определенные там действия.
  Если контроллер или view не меняются, их копировать из родителя в потомка не надо.
- Чтобы наследовались assets-ы и модели надо вместо прямого вызова использовать специальное API:
  * во-первых, чтобы это работало, эти классы надо зарегистировать в конфиге модуля,
    например \vendor\asbsoft\yii2module\news_2b_161124\config\config.php:
      'assets' => [  // alias => имя класса
          'FrontAsset' => 'asb\yii2\modules\news_2b_161124\assets\FrontAsset',
      ],
      'models' => [  // alias => строка с именем класса или массив, описывающий Yii2-object
          'News' => 'asb\yii2\modules\news_2b_161124\models\News',
      ],
    а затем использовать в контроллере или во view
  * пример использования assets:
      вместо use asb\yii2\modules\news_1b_160430\assets\FrontAsset;
      или    use asb\yii2\modules\news_2b_161124\assets\FrontAsset;
      а затем $assets = FrontAsset::register($this);
      во view используется
        $assets = $this->context->module->registerAsset('FrontAsset', $this);
      так будет подставляться правильный (последний) assets во все view как предка, так и потомка,
      например в модуле news_2b_161124 используется не переопределенный view из предка
      ...\news_1b_160430\views\main\view.php, который в свою очередь будет использован FrontAsset
      из модуля-наследника news_2b_161124
  * пример использования модели:
      вместо use asb\yii2\modules\news_1b_160430\models\News;
      или    use asb\yii2\modules\news_2b_161124\models\News;
      а затем $model = new News();
      используется
        $model = $this->module->model('News');
      при этом также используется та модель, которая получилась в итоговом конфиге после их слияния.
Наследование вложенных (под)модулей автоматически работать не будет, но это возможно, -
для этого необходимо в корневом модуле наследника в конфиге прописать нужный подмодуль,
м его (подмодуль) создать, указав в extends, кого он наследует из родительского модуля.
Причем, в качестве подмодуля можно унаследовать вообще посторонний модуль (но обязательно принадлежащий классу UniModule).
Поиск в цепочке родительских модулей производится с помощью механизма reflection, обрабатываются только классы UniModule.
Примеры наследования сторонних модулей в качестве подмодулей есть в демо-приложении asbsoft/yii2-app_4_170405:
там модуль project\modules\sys\Module включает в себя подмодули
project\modules\sys\modules\user\Module extends asb\yii2\modules\users_0_170112\Module
и project\modules\sys\modules\content\Module extends asb\yii2\modules\content_2_170309\Module.


Наследование в шаблонах
-----------------------
На шаблонах можно помечать блоки:
```php
    <?php $this->startBlock('ИМЯ') ?> КОНТЕНТ <?php $this->stopBlock('ИМЯ') ?>
```
(не путать с существующими в Yii2-фреймворке yii\base\View::beginBlock(), endBlock())
которые можно переопределить в шаблонах-наследниках внутри конструкции startParent-stopParent
```php
    <?php $this->startParent(); ?> ПЕРЕОПРЕДЕЛЕННЫЕ БЛОКИ <?php $this->stopParent(); ?>
```
которая должна быть одна в шаблоне-наследнике.
Блоки могут быть вложенные. Если в шаблоне-наследнике переопределяется только вложенный блок,
ему надо давать сложное имя:
```php
    <?php $this->startBlock('ВНЕШНИЙ/.../ВНУТРЕННИЙ') ?>  КОНТЕНТ ...
```
Внутри блока можно отрендерить родительский блок с помощью <?php $this->parentBlock() ?>
Пример использования - в asbsoft/yii2module-news_3b_171202.


(c) 2017-2018, Alexandr S. Belogolovsky, ab2014box@gmail.com
